---
allowed-tools: Bash, Read, Write, LS, Task
---

# 史诗任务分解

将史诗任务分解为具体、可操作的任务。

## 用法
```
/pm:epic-decompose <feature_name>
```

## 必需规则

**重要：** 在执行此命令之前，请阅读并遵循：
- `.claude/rules/datetime.md` - 用于获取真实的当前日期/时间

## 预检清单

在继续之前，请完成这些验证步骤。
不要用预检检查进度打扰用户（"我不会..."）。只需执行并继续。

1. **验证史诗任务存在：**
   - 检查 `.claude/epics/$ARGUMENTS/epic.md` 是否存在
   - 如果未找到，告诉用户：`"❌ 未找到史诗任务: $ARGUMENTS。首先使用以下命令创建: /pm:prd-parse $ARGUMENTS"`
   - 如果史诗任务不存在则停止执行

2. **检查现有任务：**
   - 检查 `.claude/epics/$ARGUMENTS/` 中是否已存在编号任务文件（001.md, 002.md 等）
   - 如果存在任务，列出它们并询问：`"⚠️ 找到 {count} 个现有任务。删除并重新创建所有任务？(yes/no)"`
   - 仅在明确确认 'yes' 后继续
   - 如果用户说 no，建议：`"使用以下命令查看现有任务: /pm:epic-show $ARGUMENTS"`

3. **验证史诗任务 frontmatter：**
   - 验证史诗任务是否有有效的 frontmatter，包含：name, status, created, prd
   - 如果无效，告诉用户：`"❌ 无效的史诗任务 frontmatter。请检查: .claude/epics/$ARGUMENTS/epic.md"`

4. **检查史诗任务状态：**
   - 如果史诗任务状态已为"completed"，警告用户：`"⚠️ 史诗任务标记为已完成。您确定要再次分解它吗？"`

## 指令

您正在为以下内容将史诗任务分解为特定、可操作的任务：**$ARGUMENTS**

### 1. 读取史诗任务
- 从 `.claude/epics/$ARGUMENTS/epic.md` 加载史诗任务
- 理解技术方法和要求
- 审查任务分解预览

### 2. 分析并行创建

确定任务是否可以并行创建：
- 如果任务大多是独立的：使用 Task 代理并行创建
- 如果任务有复杂依赖关系：顺序创建
- 为获得最佳结果：将独立任务分组进行并行创建

### 3. 并行任务创建（当可能时）

如果任务可以并行创建，则生成子代理：

```yaml
Task:
  description: "创建任务文件批次 {X}"
  subagent_type: "general-purpose"
  prompt: |
    为史诗任务创建任务文件: $ARGUMENTS

    要创建的任务:
    - {此批次的 3-4 个任务列表}

    对于每个任务:
    1. 创建文件: .claude/epics/$ARGUMENTS/{number}.md
    2. 使用确切格式，包含 frontmatter 和所有部分
    3. 遵循史诗任务中的任务分解
    4. 适当设置 parallel/depends_on 字段
    5. 顺序编号 (001.md, 002.md, 等)

    返回: 已创建文件列表
```

### 4. 带 Frontmatter 的任务文件格式
对于每个任务，创建具有此确切结构的文件：

```markdown
---
name: [任务标题]
status: open
created: [当前 ISO 日期/时间]
updated: [当前 ISO 日期/时间]
github: [同步到 GitHub 时将更新]
depends_on: []  # 此任务依赖的任务编号列表，例如 [001, 002]
parallel: true  # 此任务是否可以与其他任务并行运行？
conflicts_with: []  # 修改相同文件的任务，例如 [003, 004]
---

# 任务: [任务标题]

## 描述
需要完成的工作的清晰、简洁描述

## 验收标准
- [ ] 具体标准 1
- [ ] 具体标准 2
- [ ] 具体标准 3

## 技术细节
- 实现方法
- 关键考虑因素
- 受影响的代码位置/文件

## 依赖项
- [ ] 任务/问题依赖项
- [ ] 外部依赖项

## 工作量估算
- 大小: XS/S/M/L/XL
- 小时数: 估算小时数
- 并行: true/false (是否可以与其他任务并行运行)

## 完成定义
- [ ] 代码已实现
- [ ] 测试已编写并通过
- [ ] 文档已更新
- [ ] 代码已审查
- [ ] 已部署到暂存环境
```

### 3. 任务命名约定
将任务保存为：`.claude/epics/$ARGUMENTS/{task_number}.md`
- 使用顺序编号：001.md, 002.md, 等
- 保持任务标题简短但具有描述性

### 4. Frontmatter 指南
- **name**: 使用描述性任务标题（不带"Task:"前缀）
- **status**: 新任务始终以"open"开始
- **created**: 通过运行获取真实的当前日期时间：`date -u +"%Y-%m-%dT%H:%M:%SZ"`
- **updated**: 新任务使用与创建相同的实际日期时间
- **github**: 留下占位符文本 - 同步时将更新
- **depends_on**: 列出必须在此任务开始前完成的任务编号（例如，[001, 002]）
- **parallel**: 如果此任务可以与其他任务同时运行而无冲突，则设置为 true
- **conflicts_with**: 列出修改相同文件的任务编号（有助于协调）

### 5. 考虑的任务类型
- **设置任务**: 环境、依赖项、脚手架
- **数据任务**: 模型、模式、迁移
- **API 任务**: 端点、服务、集成
- **UI 任务**: 组件、页面、样式
- **测试任务**: 单元测试、集成测试
- **文档任务**: README、API 文档
- **部署任务**: CI/CD、基础设施

### 6. 并行化
如果任务可以同时运行而无冲突，则标记任务为 `parallel: true`。

### 7. 执行策略

根据任务数量和复杂性选择：

**小史诗任务 (< 5 个任务)**: 顺序创建以简化

**中等史诗任务 (5-10 个任务)**:
- 分批为 2-3 组
- 为每批生成代理
- 整合结果

**大史诗任务 (> 10 个任务)**:
- 首先分析依赖关系
- 分组独立任务
- 启动并行代理（最多 5 个并发）
- 在先决条件完成后创建依赖任务

并行执行示例：
```markdown
生成 3 个代理进行并行任务创建:
- 代理 1: 创建任务 001-003 (数据库层)
- 代理 2: 创建任务 004-006 (API 层)
- 代理 3: 创建任务 007-009 (UI 层)
```

### 8. 任务依赖验证

创建有依赖关系的任务时：
- 确保引用的依赖项存在（例如，如果任务 003 依赖于任务 002，验证 002 已创建）
- 检查循环依赖（任务 A → 任务 B → 任务 A）
- 如果发现依赖问题，警告但继续：`"⚠️ 任务依赖警告: {details}"`

### 9. 使用任务摘要更新史诗任务
创建所有任务后，通过添加此部分更新史诗任务文件：
```markdown
## 已创建任务
- [ ] 001.md - {任务标题} (并行: true/false)
- [ ] 002.md - {任务标题} (并行: true/false)
- 等等.

总任务数: {count}
并行任务数: {parallel_count}
顺序任务数: {sequential_count}
估计总工作量: {小时数之和}
```

如果需要，也更新史诗任务的 frontmatter 进度（在任务实际开始前仍为 0%）。

### 9. 质量验证

在最终确定任务前，验证：
- [ ] 所有任务都有清晰的验收标准
- [ ] 任务大小合理（每个 1-3 天）
- [ ] 依赖关系是逻辑且可实现的
- [ ] 并行任务不会相互冲突
- [ ] 组合任务涵盖所有史诗任务要求

### 10. 分解后

成功创建任务后：
1. 确认：`"✅ 为史诗任务创建了 {count} 个任务: $ARGUMENTS"`
2. 显示摘要：
   - 已创建总任务数
   - 并行与顺序分解
   - 总估计工作量
3. 建议下一步：`"准备好同步到 GitHub？运行: /pm:epic-sync $ARGUMENTS"`

## 错误恢复

如果任何步骤失败：
- 如果任务创建部分完成，列出已创建的任务
- 提供清理部分任务的选项
- 永不将史诗任务置于不一致状态

目标是每个任务可在 1-3 天内完成。将较大的任务分解为更小、可管理的部分，用于"$$ARGUMENTS"史诗任务。