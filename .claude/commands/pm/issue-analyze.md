---
allowed-tools: Bash, Read, Write, LS
---

# 问题分析

分析问题以识别并行工作流以实现最大效率。

## 用法
```
/pm:issue-analyze <issue_number>
```

## 快速检查

1. **查找本地任务文件：**
   - 首先检查 `.claude/epics/*/$ARGUMENTS.md` 是否存在（新命名约定）
   - 如果未找到，搜索 frontmatter 中包含 `github:.*issues/$ARGUMENTS` 的文件（旧命名）
   - 如果未找到：`"❌ 问题 #$ARGUMENTS 无本地任务。运行: /pm:import 首先"`

2. **检查现有分析：**
   ```bash
   test -f .claude/epics/*/$ARGUMENTS-analysis.md && echo "⚠️ 分析已存在。覆盖？(yes/no)"
   ```

## 指令

### 1. 读取问题上下文

从 GitHub 获取问题详情：
```bash
gh issue view $ARGUMENTS --json title,body,labels
```

读取本地任务文件以理解：
- 技术要求
- 验收标准
- 依赖项
- 工作量估算

### 2. 识别并行工作流

分析问题以识别可并行运行的独立工作：

**常见模式：**
- **数据库层**：模式、迁移、模型
- **服务层**：业务逻辑、数据访问
- **API层**：端点、验证、中间件
- **UI层**：组件、页面、样式
- **测试层**：单元测试、集成测试
- **文档**：API文档、README更新

**关键问题：**
- 将创建/修改哪些文件？
- 哪些更改可以独立进行？
- 更改之间有什么依赖关系？
- 哪里可能发生冲突？

### 3. 创建分析文件

获取当前日期时间：`date -u +"%Y-%m-%dT%H:%M:%SZ"`

创建 `.claude/epics/{epic_name}/$ARGUMENTS-analysis.md`：

```markdown
---
issue: $ARGUMENTS
title: {问题标题}
analyzed: {current_datetime}
estimated_hours: {总小时数}
parallelization_factor: {1.0-5.0}
---

# 并行工作分析: Issue #$ARGUMENTS

## 概述
{需要做什么的简要描述}

## 并行流

### 流 A: {流名称}
**范围**: {此流处理的内容}
**文件**:
- {文件模式_1}
- {文件模式_2}
**代理类型**: {后端|前端|全栈|数据库}-专家
**可开始**: 立即
**估算小时数**: {小时数}
**依赖项**: 无

### 流 B: {流名称}
**范围**: {此流处理的内容}
**文件**:
- {文件模式_1}
- {文件模式_2}
**代理类型**: {代理类型}
**可开始**: 立即
**估算小时数**: {小时数}
**依赖项**: 无

### 流 C: {流名称}
**范围**: {此流处理的内容}
**文件**:
- {文件模式_1}
**代理类型**: {代理类型}
**可开始**: 流 A 完成后
**估算小时数**: {小时数}
**依赖项**: 流 A

## 协调点

### 共享文件
{列出多个流需要修改的任何文件}:
- `src/types/index.ts` - 流 A & B (协调类型更新)
- `package.json` - 流 B (添加依赖项)

### 顺序要求
{列出必须按顺序进行的内容}:
1. 数据库模式在 API 端点之前
2. API 类型在 UI 组件之前
3. 核心逻辑在测试之前

## 冲突风险评估
- **低风险**: 流在不同目录工作
- **中风险**: 一些共享类型文件，可通过协调管理
- **高风险**: 多个流修改相同的核心文件

## 并行化策略

**推荐方法**: {顺序|并行|混合}

{如果并行}: 同时启动流 A、B。A 完成后启动 C。
{如果顺序}: 完成流 A，然后 B，然后 C。
{如果混合}: 同时启动 A & B，C 依赖于 A，D 依赖于 B & C。

## 预期时间线

并行执行：
- 墙钟时间: {最大流小时数} 小时
- 总工作量: {所有小时数之和} 小时
- 效率提升: {百分比}%

非并行执行：
- 墙钟时间: {所有小时数之和} 小时

## 说明
{任何特殊考虑、警告或建议}
```

### 4. 验证分析

确保：
- 所有主要工作都由流覆盖
- 文件模式不会不必要地重叠
- 依赖关系是合理的
- 代理类型与工作类型匹配
- 时间估算是合理的

### 5. 输出

```
✅ 问题 #$ARGUMENTS 分析完成

识别出 {count} 个并行工作流：
  流 A: {名称} ({小时数}h)
  流 B: {名称} ({小时数}h)
  流 C: {名称} ({小时数}h)
  
并行化潜力: {因子}x 加速
  顺序时间: {总时间}h
  并行时间: {减少时间}h

可能发生冲突的文件：
  {如果有的话列出共享文件}

下一步: 使用 /pm:issue-start $ARGUMENTS 开始工作
```

## 重要说明

- 分析仅限本地 - 不同步到 GitHub
- 关注实际并行化，而非理论最大值
- 分配流时考虑代理专业知识
- 在估算中考虑协调开销
- 优先考虑清晰分离而非最大并行化